<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Daniel Butler</title>
        <link>https://daniel-butler.com</link>
        <description>A collection of thoughts</description>
        <lastBuildDate>Sun, 22 Feb 2026 18:29:04 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Daniel Butler</title>
            <url>https://daniel-butler.com/favicon.ico</url>
            <link>https://daniel-butler.com</link>
        </image>
        <copyright>All rights reserved 2026</copyright>
        <item>
            <title><![CDATA[Sheetmask released!]]></title>
            <link>https://daniel-butler.com/articles/sheetmask-initial-release</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/sheetmask-initial-release</guid>
            <pubDate>Sun, 22 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[Sheetmask anonymizes your data and keeps relationships intact. It is great for PnLs and other financial data where the structure matters.]]></description>
            <content:encoded><![CDATA[<p>I built <a href="https://github.com/daniel-butler/sheetmask">sheetmask</a> to solve a specific problem: you have a real Excel report full of sensitive data and need a safe test fixture that matches its structure. Not a made-up spreadsheet. Something that looks and behaves like the real thing, without the real names and numbers.</p>
<p>Most anonymization tools stop at replacing values. Sheetmask reads the file&#x27;s structure first: which sheets exist, what columns are in each, what the data types are, and how numbers relate to each other. That structural map makes the rest possible.</p>
<h2>The workflow</h2>
<p>Run <code>analyze</code> on your file:</p>
<pre><code class="hljs language-bash">sheetmask analyze <span class="hljs-string">&quot;Q4 Finance Report.xlsx&quot;</span>
</code></pre>
<p>This prints a structured prompt describing the file&#x27;s sheets, columns, data types, and sample values. It captures which columns are derived (Gross Margin = Revenue - Cost) and which entities repeat across sheets (a manager name appearing in both a summary tab and a detail tab).</p>
<p>Copy that prompt and paste it into Claude or ChatGPT. The LLM reads the structural analysis and writes a processor config telling sheetmask exactly how to handle each column: what kind of fake value to generate, which numeric columns to vary independently, and which to derive from others so the math stays consistent.</p>
<p>Save the config the LLM returns, then run <code>process</code>:</p>
<pre><code class="hljs language-bash">sheetmask process <span class="hljs-string">&quot;Q4 Finance Report.xlsx&quot;</span> --config q4_config.py
<span class="hljs-comment"># Output: Q4 Finance Report_SYNTHETIC.xlsx</span>
</code></pre>
<h2>Why the LLM step is not optional</h2>
<p>The config maps every column to a rule. Writing it by hand means reading each column, understanding the data type, deciding whether a number is independent or computed, and getting the formulas right across however many sheets the file has.</p>
<p>The LLM does that work. It reads the sample data and the structure <code>analyze</code> extracted, understands the relationships, and produces a config sheetmask executes directly. You review it, run it, and get a synthetic file with fake names and fake numbers but real structure.</p>
<p><code>analyze</code> does the structural work. The LLM does the semantic work. Together, they produce output that works as an actual test fixture.</p>
<h2>Install</h2>
<pre><code class="hljs language-bash">pip install git+https://github.com/daniel-butler/sheetmask.git
</code></pre>
<pre><code class="hljs language-bash">uv add git+https://github.com/daniel-butler/sheetmask.git
</code></pre>
<p>Source and docs: <a href="https://github.com/daniel-butler/sheetmask">https://github.com/daniel-butler/sheetmask</a></p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[The prompt everyone should know]]></title>
            <link>https://daniel-butler.com/articles/you-try-it</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/you-try-it</guid>
            <pubDate>Fri, 20 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[it's so simple you should try it!]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>you try it</p>
</blockquote>
<p>yes. really. that&#x27;s the whole prompt that can change your entire relationship with llms/ai.
it&#x27;s absolutely magical the first time you see it.</p>
<p>the biggest thing is you have to do this from a local agent environment like Claude Code, Cowork, codex, etc.</p>
<p>try it and let me know what you think.</p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Caching Mental Model]]></title>
            <link>https://daniel-butler.com/articles/caches-mental-model</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/caches-mental-model</guid>
            <pubDate>Wed, 29 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[A way to think about caching in computer science]]></description>
            <content:encoded><![CDATA[<p>Caches are like trash cans.
When throwing out trash it goes in the closest bin.
We don&#x27;t walk to the trash can in the garage or outside everytime.
We collect it in different sized bins around the house.</p>
<p>Read through caches are when the closest can is overflowing.
It goes in the larger one in the kitchen.</p>
<p>Cache time to live (TTL) is trash days.
The trash is &quot;expired&quot; and it has to leave.</p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[AWS Outage - Network Load Balancer Take]]></title>
            <link>https://daniel-butler.com/articles/aws-outage-2025-10</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/aws-outage-2025-10</guid>
            <pubDate>Mon, 27 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[Flapping in the wild.]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>The opinions and information expressed in this post, and every other one, are my own and in no way reflect the opinion of my employer, Amazon.</p>
</blockquote>
<p>A lot has been discussed about AWS’s DynamoDB outage already. If you haven’t read it, yet I suggest spending a few minutes to go through it. The best lessons are from the scars of others!</p>
<p><a href="https://aws.amazon.com/message/101925/">https://aws.amazon.com/message/101925/</a></p>
<p>There is already a lot on the DNS delegators and how they failed. What I found interesting from reading between the lines was the Network Load Balancer (NLB) failure. AWS has another type of load balancer, Application load balancers (ALB). The ALBs weren’t impacted, why?</p>
<p>The answer basically comes down to a case of real world flapping. This is the NLB quote from the report.</p>
<blockquote>
<p>During the event the NLB health checking subsystem began to experience increased health check failures. This was caused by the health checking subsystem bringing new EC2 instances into service while the network state for those instances had not yet fully propagated. This meant that in some cases health checks would fail even though the underlying NLB node and backend targets were healthy. This resulted in health checks alternating between failing and healthy. This caused NLB nodes and backend targets to be removed from DNS, only to be returned to service when the next health check succeeded.</p>
</blockquote>
<p>The likely cause is Network Load Balancers passive health checks - Application Load Balancers don&#x27;t have them.  Active health checks are calls to endpoint like <code>/health</code> while passive health checks monitor actual connections.</p>
<blockquote>
<p>With passive health checks, the load balancer observes how targets respond to connections. Passive health checks enable the load balancer to detect an unhealthy target before it is reported as unhealthy by the active health checks. You cannot disable, configure, or monitor passive health checks. Passive health checks are not supported for UDP traffic, and target groups with stickiness turned on.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-health-checks.html">Documentation Link</a></li>
</ul>
</blockquote>
<p>The key point is passive health checks watch the actual traffic. There is no slack for errors.  Some requests worked while others didn&#x27;t causing the targets to flap (<code>fail</code> -&gt; <code>succeed</code> -<code>fail</code> -&gt; <code>succeed</code> -&gt; etc).</p>
<p>It’s one of those hard lessons of why you don’t necessary want instantaneous feedback. Quick feedback is good but overwhelming feedback becomes noise or worse.</p>
<p>I’m an outsider looking in, it seems like the biggest mismatch is the resource server wasn’t protected from its clients. Generally throttling is how that protection is implemented.</p>
<h3>Bonus</h3>
<p>Below is a visual representation of the failures and the cascading effect it had. The team I am on was impacted after the NLB failures were resolved.</p>
<pre class="mermaid">gantt
      title AWS US-EAST-1 Outage - Service Impact Timeline (14.5 hours)
      dateFormat YYYY-MM-DD HH:mm

      section Root Cause
      DynamoDB DNS Failure           :crit, 2025-10-19 23:48, 2025-10-20 02:40

      section Lambda
      Lambda Wave 1 (DynamoDB)       :w1lambda, 2025-10-19 23:51, 2025-10-20 02:24
      Lambda SQS Polling Issue       :active, 2025-10-20 02:24, 2025-10-20 06:00
      Lambda Wave 2 (NLB)            :done, 2025-10-20 07:04, 2025-10-20 14:15

      section Connect
      Connect Wave 1 (DynamoDB)      :w1connect, 2025-10-19 23:56, 2025-10-20 05:00
      Connect Wave 2 (NLB)           :done, 2025-10-20 07:04, 2025-10-20 13:20

      section EC2 Cascade
      EC2 DWFM Failures             :active, 2025-10-19 23:48, 2025-10-20 05:28
      EC2 Network State Issues      :active, 2025-10-20 05:28, 2025-10-20 10:36
      EC2 Throttling Recovery       :active, 2025-10-20 10:36, 2025-10-20 13:50

      section NLB Cascade
      NLB Connection Errors         :done, 2025-10-20 05:30, 2025-10-20 14:09

      section Other Services
      STS Wave 1 (DynamoDB)          :w1other, 2025-10-19 23:51, 2025-10-20 01:19
      STS Wave 2 (NLB)               :done, 2025-10-20 08:31, 2025-10-20 09:59
      Console Auth (DynamoDB)        :w1other, 2025-10-19 23:51, 2025-10-20 01:25
      Redshift Query Failures (DDB)  :w1other, 2025-10-19 23:47, 2025-10-20 02:21
      Redshift Cluster Impairment (EC2) :active, 2025-10-20 02:21, 2025-10-21 04:05
      ECS EKS Fargate (EC2)          :w1other, 2025-10-19 23:45, 2025-10-20 14:20
</pre>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[AI Assistants Mental Model]]></title>
            <link>https://daniel-butler.com/articles/ai-buddy-mental-modal</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/ai-buddy-mental-modal</guid>
            <pubDate>Sun, 26 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[A surprisingly accurate and funny take on AI models]]></description>
            <content:encoded><![CDATA[<blockquote>
<p>my mental model for AI coding assistants is an <em>incredibly</em> well-read junior engineer with questionable taste, unlimited enthusiasm, no ego, ADHD, and a traumatic brain injury that causes pretty serious memory issues. If they write something down, they&#x27;re good. They&#x27;ve developed all sorts of wild coping strategies that are far more effective than they have any right to be. They generally have no spine and back down way too fast when you question something they&#x27;re doing...even if they&#x27;re right. They&#x27;re prone to distraction. Again, getting them to write down what they&#x27;re supposed to be doing can help a ton.</p>
<ul>
<li>Jesse <a href="https://blog.fsck.com/2025/05/22/that-was-easy--a-keyboard-for-vibecoding/">https://blog.fsck.com/2025/05/22/that-was-easy--a-keyboard-for-vibecoding/</a></li>
</ul>
</blockquote>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Rust Book Dynamic Traits Example]]></title>
            <link>https://daniel-butler.com/articles/rust-dyn-traits-example</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/rust-dyn-traits-example</guid>
            <pubDate>Fri, 05 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Expanding on the example in Rust Book's chapter 17 section 3. Refactored with ChatGPT 4s help.]]></description>
            <content:encoded><![CDATA[<h2>Overview</h2>
<p>The example comes from the prompt below in the <a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html">rust book&#x27;s chapter 17 section 3</a>.</p>
<blockquote>
<p>To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</p>
<ul>
<li>Add a <code>reject</code> method that changes the post’s state from <code>PendingReview</code> back to <code>Draft</code>.</li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</li>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the <code>Post</code>.</li>
</ul>
</blockquote>
<h3>Result</h3>
<p>Below is the code I wrote to solve the three challenges above. I struggled with getting the value for the <code>Optional&lt;Box&lt;...&gt;&gt;</code>. I&#x27;m starting to grasp that it all goes back to the types when working with rust. Types are not as big of a deal in Python, so that is taking some getting used to.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> blog::Post;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">post</span> = Post::<span class="hljs-title function_ invoke__">new</span>();

    post.<span class="hljs-title function_ invoke__">add_text</span>(<span class="hljs-string">&quot;I ate a salad for lunch today&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;&quot;</span>, post.<span class="hljs-title function_ invoke__">content</span>());

    post.<span class="hljs-title function_ invoke__">request_review</span>();
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;&quot;</span>, post.<span class="hljs-title function_ invoke__">content</span>());
	
	post.<span class="hljs-title function_ invoke__">reject</span>();
	<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;&quot;</span>, post.<span class="hljs-title function_ invoke__">content</span>());
	
	post.<span class="hljs-title function_ invoke__">request_review</span>();
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;&quot;</span>, post.<span class="hljs-title function_ invoke__">content</span>());
	
	post.<span class="hljs-title function_ invoke__">approve</span>();
	post.<span class="hljs-title function_ invoke__">approve</span>();
	<span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;I ate a salad for lunch today&quot;</span>, post.<span class="hljs-title function_ invoke__">content</span>());
}


<span class="hljs-keyword">mod</span> blog {
	<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> {
		state: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;&gt;,
		content: <span class="hljs-type">String</span>,
	}
	
	<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Post</span> {
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Post {
			Post {
				state: <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Draft {})),
				content: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>(),
			}
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-type">str</span>) {
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">as_ref</span>() {
				<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can add content: {}&quot;</span>, s.<span class="hljs-title function_ invoke__">can_add_content</span>());
			
				<span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">can_add_content</span>() {
					<span class="hljs-keyword">self</span>.content.<span class="hljs-title function_ invoke__">push_str</span>(text);
				}
			}
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> {
			<span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">content</span>(<span class="hljs-keyword">self</span>);
			<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;content: {}&quot;</span>, content);
			content
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() {
				<span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">request_review</span>())
			}
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() {
				<span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">approve</span>());
			}
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() {
				<span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">reject</span>());
			}
		}
	}
	
	<span class="hljs-keyword">trait</span> <span class="hljs-title class_">State</span> {
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, _post: &amp;<span class="hljs-symbol">&#x27;a</span> Post) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> {
		 	<span class="hljs-string">&quot;&quot;</span>
		 }
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_add_content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
			<span class="hljs-literal">false</span>
		}
	}

	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Draft</span> {}
	
	<span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Draft</span> {
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
			<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(PendingReview::<span class="hljs-title function_ invoke__">new</span>())
		}
		
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
		 	<span class="hljs-keyword">self</span>
		}
		 
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
		 	<span class="hljs-keyword">self</span>
		}
		 
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_add_content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
			<span class="hljs-literal">true</span>
		}
	}
	
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PendingReview</span> {
		reviews: <span class="hljs-type">i8</span>
	}
	<span class="hljs-keyword">impl</span> <span class="hljs-title class_">PendingReview</span> {
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> PendingReview {
			PendingReview { reviews: <span class="hljs-number">0</span> }
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_review</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
			<span class="hljs-keyword">self</span>.reviews += <span class="hljs-number">1</span>;
		}
		
		<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_reviews</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i8</span> {
			<span class="hljs-keyword">self</span>.reviews
		}
	}
	<span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">PendingReview</span> {
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
			<span class="hljs-keyword">self</span>
		}
		
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
			<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">state</span> = PendingReview::<span class="hljs-title function_ invoke__">new</span>();
			state.<span class="hljs-title function_ invoke__">add_review</span>();
		
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">get_reviews</span>() == <span class="hljs-number">0</span> {
				<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(state)
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Published {})
			}
		}
		
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
		 	<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Draft {})
		 }
	}
	
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Published</span> {}
	
	<span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Published</span> {
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
			<span class="hljs-keyword">self</span>
		}
		
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
		 	<span class="hljs-keyword">self</span>
		 }
		 
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; {
		 	<span class="hljs-keyword">self</span>
		 }
		 
		<span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, post: &amp;<span class="hljs-symbol">&#x27;a</span> Post) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> {
			&amp;post.content
		}
	}
}
</code></pre>
<h2>Refinement</h2>
<p>Now, what can be learned from asking ChatGPT?</p>
<p>Open AI&#x27;s ChatGPT prompt.</p>
<pre><code>Refactor this code to be more performant.
</code></pre>
<h3>Response</h3>
<p>One possible way to make the code more performant is to avoid unnecessary allocations and cloning of data. One such example is in the <code>content()</code> method of the <code>State</code> trait, where the content is cloned unnecessarily.</p>
<ol>
<li>Instead, we can use a reference to the existing content to avoid the clone:</li>
</ol>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, post: &amp;<span class="hljs-symbol">&#x27;a</span> Post) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> {
    &amp;post.content
}
</code></pre>
<ol start="2">
<li>Similarly, in the <code>add_text()</code> method of the <code>Post</code> struct, we can use a reference to the text to avoid the allocation and copying of the string:</li>
</ol>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-type">str</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">as_ref</span>() {
        <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">can_add_content</span>() {
            <span class="hljs-keyword">self</span>.content.<span class="hljs-title function_ invoke__">push_str</span>(text);
        }
    }
}
</code></pre>
<ol start="3">
<li>We can also avoid unnecessary boxing and dynamic dispatch by using an enum instead of a trait object for the state of the post. This can simplify the code and make it more efficient:</li>
</ol>
<pre><code class="hljs language-rust"><span class="hljs-keyword">mod</span> blog {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> {
        state: State,
        content: <span class="hljs-type">String</span>,
    }

    <span class="hljs-meta">#[derive(Debug)]</span>
    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> {
        Draft { can_add_content: <span class="hljs-type">bool</span> },
        PendingReview { reviews: <span class="hljs-type">i8</span> },
        Published,
    }

    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Post</span> {
        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Post {
            Post {
                state: State::Draft { can_add_content: <span class="hljs-literal">true</span> },
                content: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>(),
            }
        }

        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-type">str</span>) {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">State</span>::Draft { can_add_content: <span class="hljs-literal">true</span> } = <span class="hljs-keyword">self</span>.state {
                <span class="hljs-keyword">self</span>.content.<span class="hljs-title function_ invoke__">push_str</span>(text);
            }
        }

        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">State</span>::Published = <span class="hljs-keyword">self</span>.state {
                &amp;<span class="hljs-keyword">self</span>.content
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-string">&quot;&quot;</span>
            }
        }

        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">State</span>::Draft { .. } = <span class="hljs-keyword">self</span>.state {
                <span class="hljs-keyword">self</span>.state = State::PendingReview { reviews: <span class="hljs-number">0</span> };
            }
        }

        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">State</span>::PendingReview { reviews } = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.state {
                *reviews += <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> *reviews &gt;= <span class="hljs-number">2</span> {
                    <span class="hljs-keyword">self</span>.state = State::Published;
                }
            }
        }

        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">State</span>::PendingReview { .. } = <span class="hljs-keyword">self</span>.state {
                <span class="hljs-keyword">self</span>.state = State::Draft { can_add_content: <span class="hljs-literal">true</span> };
            }
        }
    }
}
</code></pre>
<p>With these changes, the code should be more efficient and performant.</p>
<h2>Summary</h2>
<p>For the first two points, as best I can tell, it is already happening. And the last point is fair and even called out in the rusty book. We used <code>Box</code>s to show how they work with <code>dyn trait</code>s. Overall because I didn&#x27;t come up with a majority of the code it didn&#x27;t leave a lot of room for ChatGPT to fix it.</p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Good Reads]]></title>
            <link>https://daniel-butler.com/articles/reading-list</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/reading-list</guid>
            <pubDate>Fri, 17 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Collection of articles]]></description>
            <content:encoded><![CDATA[<h1>Overview</h1>
<p>List of articles I&#x27;ve found helpful, insightful, and want to remember.</p>
<h2>List</h2>
<ul>
<li><a href="https://www.scattered-thoughts.net/writing/reflections-on-a-decade-of-coding">https://www.scattered-thoughts.net/writing/reflections-on-a-decade-of-coding</a></li>
<li><a href="https://skamille.medium.com/an-incomplete-list-of-skills-senior-engineers-need-beyond-coding-8ed4a521b29f">https://skamille.medium.com/an-incomplete-list-of-skills-senior-engineers-need-beyond-coding-8ed4a521b29f</a></li>
</ul>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Rust HR Example Question]]></title>
            <link>https://daniel-butler.com/articles/hr-application</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/hr-application</guid>
            <pubDate>Wed, 08 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Rust Book example and solution to the HR application exercise.]]></description>
            <content:encoded><![CDATA[<h1>Overview</h1>
<p>This is <a href="https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#summary">the third example problem</a> from the rust book. As before there will be a python example then the Rust example.</p>
<h2>Problem Statement</h2>
<p>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, “Add Sally to Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</p>
<h3>Input</h3>
<pre><code>Add Sally to Engineering
Add Amir to Sales
Add Juan to Accounting
Add George to HR
Add Eric to Sales
Add Sam to Engineering
Add Cole to Engineering
List Employees
List Sales
List Engineering
List HR
</code></pre>
<h2>Python</h2>
<p>This uses a simple while loop and stores the data in a dictionary by department which is flattened with a simple list comprehension.</p>
<pre><code class="hljs language-python">employees = {}
repeat = <span class="hljs-literal">True</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">company</span>(<span class="hljs-params">command</span>):
	command_words = command.split(<span class="hljs-string">&quot; &quot;</span>)
	cmd = command_words[<span class="hljs-number">0</span>].lower()
	<span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;add&quot;</span>:
		name = command_words[<span class="hljs-number">1</span>]
		department = command_words[<span class="hljs-number">3</span>].lower()
		emp_department = employees.get(department, [])
		emp_department.append(name)
		employees[department] = emp_department
		<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Added <span class="hljs-subst">{name}</span> to <span class="hljs-subst">{department}</span>!&quot;</span>)
	<span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&quot;list&quot;</span>:
		list_type = command_words[<span class="hljs-number">1</span>].lower()
		<span class="hljs-keyword">if</span> list_type == <span class="hljs-string">&quot;employees&quot;</span>:
			emps = [
				emp
				<span class="hljs-keyword">for</span> emps_dep <span class="hljs-keyword">in</span> employees.values()
				<span class="hljs-keyword">for</span> emp <span class="hljs-keyword">in</span> emps_dep
			]
			emps.sort()
			<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Employees: <span class="hljs-subst">{emps}</span>&quot;</span>)
		<span class="hljs-keyword">else</span>:
			emps = employees.get(list_type, [])
			emps.sort()
			<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Employees in Department <span class="hljs-subst">{list_type}</span>: <span class="hljs-subst">{emps}</span>&quot;</span>)
	<span class="hljs-keyword">elif</span> cmd <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;quit&quot;</span>]:
		<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Exiting...&quot;</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>


<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Welcome: to the employee directory! when you are done type exit.\n============================\n&quot;</span>)

<span class="hljs-keyword">while</span> repeat:
	command = <span class="hljs-built_in">input</span>()
	repeat = company(command)
	
</code></pre>
<p>Output</p>
<pre><code>Welcome: to the employee directory! when you are done type exit.
============================

Add Sally to Engineering
Added Sally to engineering!
Add Amir to Sales
Added Amir to sales!
Add Juan to Accounting
Added Juan to accounting!
Add George to HR
Added George to hr!
Add Eric to Sales
Added Eric to sales!
Add Sam to Engineering
Added Sam to engineering!
Add Cole to Engineering
Added Cole to engineering!
list employees 
Employees: [&#x27;Amir&#x27;, &#x27;Cole&#x27;, &#x27;Eric&#x27;, &#x27;George&#x27;, &#x27;Juan&#x27;, &#x27;Sally&#x27;, &#x27;Sam&#x27;]
list sales
Employees in Department sales: [&#x27;Amir&#x27;, &#x27;Eric&#x27;]
list engineering
Employees in Department engineering: [&#x27;Cole&#x27;, &#x27;Sally&#x27;, &#x27;Sam&#x27;]
list hr 
Employees in Department hr: [&#x27;George&#x27;]
exit
Exiting...
</code></pre>
<h2>Rust</h2>
<p>This is my original rust solution. The solution takes advantage of the lessons learned from the median and mode refactoring by using entries when modifying <code>HashMap</code>s. When running into issues about typing being off or the size not being known at compile time, the errors made more sense. The stack vs. the heap is an integral concept that is never touched on in python.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::HashMap;
<span class="hljs-keyword">use</span> std::io;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">employees_real</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">repeat</span> = <span class="hljs-literal">true</span>;
	
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Welcome: to the employee directory! when you are done type exit.&quot;</span>);
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;============================&quot;</span>);
	
	<span class="hljs-keyword">while</span> repeat {
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();
		io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> input).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Invalid input!&quot;</span>);
		<span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = input.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">to_string</span>();
		<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Input: {}&quot;</span>, input);
		repeat = <span class="hljs-title function_ invoke__">record_employee</span>(&amp;input, &amp;<span class="hljs-keyword">mut</span> employees_real);
	}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">record_employee</span>(command: &amp;<span class="hljs-type">String</span>, employees: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
	<span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">map</span>(<span class="hljs-type">String</span>::from).<span class="hljs-title function_ invoke__">collect</span>();
	<span class="hljs-keyword">let</span> <span class="hljs-variable">cmd</span> = command_words[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">to_lowercase</span>();
	
	<span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;add&quot;</span> {
		<span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_string</span>();
		<span class="hljs-keyword">let</span> <span class="hljs-variable">dep</span> = command_words[<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">to_lowercase</span>();
		<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Added {} to {}&quot;</span>, name, dep);
		employees.<span class="hljs-title function_ invoke__">entry</span>(dep).<span class="hljs-title function_ invoke__">or_insert_with</span>(<span class="hljs-type">Vec</span>::new).<span class="hljs-title function_ invoke__">push</span>(name);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;list&quot;</span> {
		<span class="hljs-keyword">let</span> <span class="hljs-variable">list_type</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();
		
		<span class="hljs-keyword">if</span> list_type == <span class="hljs-string">&quot;employees&quot;</span> {
			<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
			<span class="hljs-keyword">for</span> (_dept, dept_emps) <span class="hljs-keyword">in</span> employees.<span class="hljs-title function_ invoke__">iter</span>() {
				<span class="hljs-keyword">for</span> <span class="hljs-variable">emp</span> <span class="hljs-keyword">in</span> dept_emps.<span class="hljs-title function_ invoke__">into_iter</span>() {
					emps.<span class="hljs-title function_ invoke__">push</span>(emp);
				}
			}
			emps.<span class="hljs-title function_ invoke__">sort</span>();
			<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">let</span> <span class="hljs-variable">nut</span> emps = employees.<span class="hljs-title function_ invoke__">get</span>(&amp;list_type).<span class="hljs-title function_ invoke__">cloned</span>().<span class="hljs-title function_ invoke__">unwrap_or_default</span>();
			emps.<span class="hljs-title function_ invoke__">sort</span>();
			<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees in Department {}: {:?}&quot;</span>, list_type, emps);
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Exiting...&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}
}
</code></pre>
<p>Output</p>
<pre><code>Welcome: to the employee directory! when you are done type exit.
============================
Input: Add Sally to Engineering
Added Sally to engineering
Input: Add Amir to Sales
Added Amir to sales
Input: Add Juan to Accounting
Added Juan to accounting
Input: Add George to HR
Added George to hr
Input: Add Eric to Sales
Added Eric to sales
Input: Add Sam to Engineering
Added Sam to engineering
Input: Add Cole to Engineering
Added Cole to engineering
Input: List Employees
Employees: [&quot;Amir&quot;, &quot;Cole&quot;, &quot;Eric&quot;, &quot;George&quot;, &quot;Juan&quot;, &quot;Sally&quot;, &quot;Sam&quot;]
Input: List Sales
Employees in Department sales: [&quot;Amir&quot;, &quot;Eric&quot;]
Input: List Engineering
Employees in Department engineering: [&quot;Cole&quot;, &quot;Sally&quot;, &quot;Sam&quot;]
Input: List HR
Employees in Department hr: [&quot;George&quot;]
Input: Exit
Exiting...
</code></pre>
<p>Looks good!!</p>
<h3>Challenges</h3>
<p>The major hurdle when creating the solution above was how to split the input by whitespace into a vector of strings.  I asked ChatGPT for some help...</p>
<blockquote>
<p>How can this error be fixed?</p>
</blockquote>
<pre><code>a value of type `Vec&lt;&amp;String&gt;` cannot be built from an iterator over elements of type `&amp;str`
</code></pre>
<blockquote>
<p>the error comes from this line of rust code:</p>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">String</span>&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">collect</span>();
</code></pre>
<p>The response which was very helpful.</p>
<blockquote>
<p>The error message suggests that the <code>split_whitespace()</code> method is returning an iterator over <code>&amp;str</code> values, but you are trying to collect them into a <code>Vec&lt;&amp;String&gt;</code>, which expects references to <code>String</code> values.
To fix this error, you can either change the type of <code>command_words</code> to <code>Vec&lt;&amp;str&gt;</code>:</p>
</blockquote>
<pre><code class="hljs language-rust">`<span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">str</span>&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">collect</span>();`
</code></pre>
<blockquote>
<p>Or you can change the type of the elements in the <code>Vec</code> to <code>String</code> instead of <code>&amp;String</code>:</p>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">map</span>(<span class="hljs-type">String</span>::from).<span class="hljs-title function_ invoke__">collect</span>();`
</code></pre>
<blockquote>
<p>The <code>map()</code> method is used to transform each <code>&amp;str</code> value into a <code>String</code> value.</p>
</blockquote>
<h2>Refactoring</h2>
<p>Now time for the refactoring!! I asked how the code above could be more idiomatic. Here was the response.</p>
<blockquote>
<p>Here are some suggestions to make the Rust code more idiomatic:</p>
</blockquote>
<blockquote>
<ol>
<li>Use pattern matching instead of if/else statements:</li>
</ol>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">match</span> cmd.<span class="hljs-title function_ invoke__">as_str</span>() {
    <span class="hljs-string">&quot;add&quot;</span> =&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_string</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">dep</span> = command_words[<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">to_lowercase</span>();
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Added {} to {}&quot;</span>, name, dep);
        employees.<span class="hljs-title function_ invoke__">entry</span>(dep).<span class="hljs-title function_ invoke__">or_insert_with</span>(<span class="hljs-type">Vec</span>::new).<span class="hljs-title function_ invoke__">push</span>(name);
        <span class="hljs-literal">true</span>
    }
    <span class="hljs-string">&quot;list&quot;</span> =&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">list_type</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();

        <span class="hljs-keyword">if</span> list_type == <span class="hljs-string">&quot;employees&quot;</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
            <span class="hljs-keyword">for</span> (_dept, dept_emps) <span class="hljs-keyword">in</span> employees.<span class="hljs-title function_ invoke__">iter</span>() {
                emps.<span class="hljs-title function_ invoke__">extend</span>(dept_emps);
            }
            emps.<span class="hljs-title function_ invoke__">sort</span>();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
            <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = employees.<span class="hljs-title function_ invoke__">get</span>(&amp;list_type).<span class="hljs-title function_ invoke__">cloned</span>().<span class="hljs-title function_ invoke__">unwrap_or_default</span>();
            emps.<span class="hljs-title function_ invoke__">sort</span>();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees in Department {}: {:?}&quot;</span>, list_type, emps);
            <span class="hljs-literal">true</span>
        }
    }
    _ =&gt; {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Exiting...&quot;</span>);
        <span class="hljs-literal">false</span>
    }
}
</code></pre>
<blockquote>
<ol start="2">
<li>Use <code>if let</code> instead of <code>unwrap_or_default</code>:</li>
</ol>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(emps) = employees.<span class="hljs-title function_ invoke__">get</span>(&amp;list_type) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = emps.<span class="hljs-title function_ invoke__">clone</span>();
    emps.<span class="hljs-title function_ invoke__">sort</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees in Department {}: {:?}&quot;</span>, list_type, emps);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Department {} not found&quot;</span>, list_type);
}
<span class="hljs-literal">true</span>
</code></pre>
<blockquote>
<ol start="3">
<li>Use <code>flatten</code> instead of nested loops:</li>
</ol>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">emps</span> = employees.<span class="hljs-title function_ invoke__">values</span>().<span class="hljs-title function_ invoke__">flatten</span>().<span class="hljs-title function_ invoke__">cloned</span>().collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
<span class="hljs-literal">true</span>

</code></pre>
<blockquote>
<ol start="4">
<li>Use <code>&amp;str</code> instead of <code>String</code> when possible:</li>
</ol>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">record_employee</span>(command: &amp;<span class="hljs-type">str</span>, employees: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">collect</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cmd</span> = command_words[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();

    <span class="hljs-keyword">match</span> cmd.<span class="hljs-title function_ invoke__">as_str</span>() {
        <span class="hljs-string">&quot;add&quot;</span> =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_string</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-variable">dep</span> = command_words[<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Added {} to {}&quot;</span>, name, dep);
            employees.<span class="hljs-title function_ invoke__">entry</span>(dep).<span class="hljs-title function_ invoke__">or_insert_with</span>(<span class="hljs-type">Vec</span>::new).<span class="hljs-title function_ invoke__">push</span>(name);
            <span class="hljs-literal">true</span>
        }
        <span class="hljs-string">&quot;list&quot;</span> =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">list_type</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();

            <span class="hljs-keyword">if</span> list_type == <span class="hljs-string">&quot;employees&quot;</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">emps</span> = employees.<span class="hljs-title function_ invoke__">values</span>().<span class="hljs-title function_ invoke__">flatten</span>().<span class="hljs-title function_ invoke__">cloned</span>().collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
                <span class="hljs-literal">true</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(emps) = employees.<span class="hljs-title function_ invoke__">get</span>(&amp;list_type) {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = emps.<span class="hljs-title function_ invoke__">clone</span>();
                emps.<span class="hljs-title function_ invoke__">sort</span>();
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees in Department {}: {:?}&quot;</span>, list_type, emps);
                <span class="hljs-literal">true</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Department {} not found&quot;</span>, list_type);
                <span class="hljs-literal">true</span>
            }
        }
        _ =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Exiting...&quot;</span>);
            <span class="hljs-literal">false</span>
        }
    }
}
</code></pre>
<blockquote>
<ol start="5">
<li>Use <code>let mut</code> only when necessary:</li>
</ol>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
<span class="hljs-keyword">for</span> <span class="hljs-variable">dept_emps</span> <span class="hljs-keyword">in</span> employees.<span class="hljs-title function_ invoke__">values</span>() {
    emps.<span class="hljs-title function_ invoke__">extend</span>(dept_emps);
}
emps.<span class="hljs-title function_ invoke__">sort</span>();
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
<span class="hljs-literal">true</span>
</code></pre>
<p>Since it is broken into a few sections. I&#x27;ve put it all into a working code block below with the exception of point #5 because it conflicts with the flatten method #3. Flatten makes more sense to me. It is debatable that #5 is a clearer way to express the logic.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::HashMap;
<span class="hljs-keyword">use</span> std::io;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">employees_real</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">repeat</span> = <span class="hljs-literal">true</span>;
	
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Welcome: to the employee directory! when you are done type exit.&quot;</span>);
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;============================&quot;</span>);
	
	<span class="hljs-keyword">while</span> repeat {
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();
		io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> input).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Invalid input!&quot;</span>);
		<span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = input.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">to_string</span>();
		<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Input: {}&quot;</span>, input);
		repeat = <span class="hljs-title function_ invoke__">record_employee</span>(&amp;input, &amp;<span class="hljs-keyword">mut</span> employees_real);
	}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">record_employee</span>(command: &amp;<span class="hljs-type">String</span>, employees: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
	<span class="hljs-keyword">let</span> <span class="hljs-variable">command_words</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = command.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">collect</span>();
	<span class="hljs-keyword">let</span> <span class="hljs-variable">cmd</span> = command_words[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();
	
	<span class="hljs-keyword">match</span> cmd.<span class="hljs-title function_ invoke__">as_str</span>() {
		
		<span class="hljs-string">&quot;add&quot;</span> =&gt; {
		    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_string</span>();
		    <span class="hljs-keyword">let</span> <span class="hljs-variable">dep</span> = command_words[<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();
		    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Added {} to {}&quot;</span>, name, dep);
		    employees.<span class="hljs-title function_ invoke__">entry</span>(dep).<span class="hljs-title function_ invoke__">or_insert_with</span>(<span class="hljs-type">Vec</span>::new).<span class="hljs-title function_ invoke__">push</span>(name);
		    <span class="hljs-literal">true</span>
	    }
		
	    <span class="hljs-string">&quot;list&quot;</span> =&gt; {
		    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_type</span> = command_words[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">to_lowercase</span>();
		
		    <span class="hljs-keyword">if</span> list_type == <span class="hljs-string">&quot;employees&quot;</span> {
			    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = employees.<span class="hljs-title function_ invoke__">values</span>().<span class="hljs-title function_ invoke__">flatten</span>().<span class="hljs-title function_ invoke__">cloned</span>().collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();
			    emps.<span class="hljs-title function_ invoke__">sort</span>();
			    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees: {:?}&quot;</span>, emps);
		    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(emps) = employees.<span class="hljs-title function_ invoke__">get</span>(&amp;list_type) {
				<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">emps</span> = emps.<span class="hljs-title function_ invoke__">clone</span>();
				emps.<span class="hljs-title function_ invoke__">sort</span>();
				<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Employees in Department {}: {:?}&quot;</span>, list_type, emps);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Department {} not found&quot;</span>, list_type);
			}
			<span class="hljs-literal">true</span>
	    }
		
	    _ =&gt; {
		    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Exiting...&quot;</span>);
		    <span class="hljs-literal">false</span>
	    }
	}
}
</code></pre>
<p>Output</p>
<pre><code>Welcome: to the employee directory! when you are done type exit.
============================
Input: Add Sally to Engineering
Added Sally to engineering
Input: Add Amir to Sales
Added Amir to sales
Input: Add Juan to Accounting
Added Juan to accounting
Input: Add George to HR
Added George to hr
Input: Add Eric to Sales
Added Eric to sales
Input: Add Sam to Engineering
Added Sam to engineering
Input: Add Cole to Engineering
Added Cole to engineering
Input: List Employees
Employees: [&quot;Amir&quot;, &quot;Cole&quot;, &quot;Eric&quot;, &quot;George&quot;, &quot;Juan&quot;, &quot;Sally&quot;, &quot;Sam&quot;]
Input: List Sales
Employees in Department sales: [&quot;Amir&quot;, &quot;Eric&quot;]
Input: List Engineering
Employees in Department engineering: [&quot;Cole&quot;, &quot;Sally&quot;, &quot;Sam&quot;]
Input: List HR
Employees in Department hr: [&quot;George&quot;]
Input: Exit
Exiting...
</code></pre>
<p>Overall I&#x27;m impressed with the result. I think it helped show how to use the <code>collect::&lt;T&gt;()</code> method to convert types and how to use <code>if let</code> idiomatically.</p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Median and Mode in Rust]]></title>
            <link>https://daniel-butler.com/articles/median-and-mode-rust</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/median-and-mode-rust</guid>
            <pubDate>Sun, 05 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[First example in the Rust book. Refactored with ChatGPT 4s help.]]></description>
            <content:encoded><![CDATA[<p>This is the second example I&#x27;m working on from the <a href="https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#summary">rust book</a>.</p>
<p>In python, I&#x27;ve used the statistics standard library module as the test case to validate the code written in the &quot;brute force method&quot;. If this was production code, I would use the statistics module instead of rolling my own.</p>
<h2>Problem Statement</h2>
<p>Given a list of integers, use a vector and return the median (when sorted, the value in the middle position) and mode (the value that occurs most often; a hash map will be helpful here) of the list.</p>
<h3>Input</h3>
<pre><code>[13, 8, 2, 21, 21, 6, 27, 15, 14, 22, 17, 16, 7, 15, 12, 10, 25, 21, 27, 29, 17, 29, 26, 10, 14, 11, 23, 8, 27, 4]
</code></pre>
<h1>Median</h1>
<p>What we are looking for is when sorted, the value in the middle position of an array of numbers. When there are an even number of values in the array then find the middle value between the two middle entries.</p>
<h2>Python</h2>
<pre><code class="hljs language-python">nums = [
		<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">27</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">22</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-number">27</span>, <span class="hljs-number">29</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">4</span>
]

nums = <span class="hljs-built_in">sorted</span>(nums)

<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
	median = nums[<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>)]
<span class="hljs-keyword">else</span>:
	middle_index = <span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span>
	first_index = <span class="hljs-built_in">int</span>(middle_index - <span class="hljs-number">.5</span>)
	second_index = <span class="hljs-built_in">int</span>(middle_index + <span class="hljs-number">.5</span>)
	median = (nums[first_index]+nums[second_index])/<span class="hljs-number">2</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Median Brute method: <span class="hljs-subst">{median}</span>&quot;</span>)

<span class="hljs-keyword">import</span> statistics
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Median Standard library method: <span class="hljs-subst">{statistics.median(nums)}</span>&quot;</span>)
</code></pre>
<p>Output</p>
<pre><code>Median Brute method: 15.5
Median Standard library method: 15.5
</code></pre>
<h2>Rust</h2>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nums</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">27</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">22</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-number">27</span>, <span class="hljs-number">29</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">4</span>];

	nums.<span class="hljs-title function_ invoke__">sort</span>();
	<span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;Median: {}&quot;</span>, <span class="hljs-title function_ invoke__">median</span>(&amp;nums))
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">median</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> {
	<span class="hljs-keyword">let</span> <span class="hljs-variable">length</span>: <span class="hljs-type">f32</span>= nums.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>;
	<span class="hljs-keyword">let</span> <span class="hljs-variable">middle_index</span>: <span class="hljs-type">f32</span> = length / <span class="hljs-number">2</span>.;
	
	<span class="hljs-keyword">match</span> nums.<span class="hljs-title function_ invoke__">len</span>() % <span class="hljs-number">2</span> {
		<span class="hljs-number">0</span> =&gt; {
			<span class="hljs-keyword">let</span> <span class="hljs-variable">first</span>= nums[(middle_index - <span class="hljs-number">0.5</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];
			<span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = nums[(middle_index + <span class="hljs-number">0.5</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];
			<span class="hljs-title function_ invoke__">return</span> (first <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span> + second <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>) / <span class="hljs-number">2</span>.
		}
		_ =&gt; {
			<span class="hljs-keyword">return</span> nums[middle_index <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>
		}
	}
}
</code></pre>
<p>Output</p>
<pre><code>Median: 15.5
</code></pre>
<h2>Challenges</h2>
<p>Not understanding Scope and types being returned. My solution was to put the logic into its own function.</p>
<pre><code>error[E0425]: cannot find value `median` in this scope
  --&gt; compiler.rs:21:23
   |
21 |     print!(&quot;Median: {}&quot;, median)
   |                          ^^^^^^ not found in this scope
</code></pre>
<p>Numbers are not all the same type. I solved it by casting the numbers into the proper type. Sometimes casting the numbers twice because <code>f32</code> can&#x27;t be cast into <code>usize</code> type. <a href="https://stackoverflow.com/a/44552464/7838574">This stack overflow</a> helped get me to the solution.</p>
<pre><code>error[E0277]: cannot subtract `{float}` from `usize`
  --&gt; compiler.rs:12:34
   |
12 |             let first = nums[middle_index - 0.5];
   |                                           ^ no implementation for `usize - {float}`
</code></pre>
<h1>Mode</h1>
<h2>Python</h2>
<pre><code class="hljs language-python">nums = [
		<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">27</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">22</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-number">27</span>, <span class="hljs-number">29</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">4</span>
]

count_dict = {}
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:
	count_dict[num] = count_dict.get(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
	
mode_dict = {}
highest = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> count_dict.items():
	val_list = mode_dict.get(value, [])
	val_list.append(key)
	mode_dict[value] = val_list
	<span class="hljs-keyword">if</span> value &gt; highest:
		highest = value

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Mode Brute force method: <span class="hljs-subst">{mode_dict[highest]}</span>&quot;</span>)

<span class="hljs-keyword">import</span> statistics
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Mode Standard library method: <span class="hljs-subst">{statistics.mode(nums)}</span>&quot;</span>)
</code></pre>
<p>Output</p>
<pre><code>Mode Brute force method: [21, 27]

statistics.StatisticsError: no unique mode; found 2 equally common values
</code></pre>
<p>The statistics standard library throws an error because there are two most common values.</p>
<h2>Rust</h2>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nums</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">27</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">22</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-number">27</span>, <span class="hljs-number">29</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">4</span>];
	
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Mode: {:?}&quot;</span>, <span class="hljs-title function_ invoke__">mode</span>(&amp;nums));
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">mode</span>(nums: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt; {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();
	
	<span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> nums {
		<span class="hljs-keyword">match</span> counter.<span class="hljs-title function_ invoke__">get</span>(&amp;num) {
			<span class="hljs-title function_ invoke__">Some</span>(count) =&gt; counter.<span class="hljs-title function_ invoke__">insert</span>(num, count + <span class="hljs-number">1</span>),
			<span class="hljs-literal">None</span> =&gt; counter.<span class="hljs-title function_ invoke__">insert</span>(num, <span class="hljs-number">1</span>)
		};
	}

	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">moder</span>: HashMap&lt;<span class="hljs-type">u32</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">highest</span> = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;counter {
		<span class="hljs-keyword">if</span> value &gt; &amp;highest {
			highest = *value;
		}
		<span class="hljs-keyword">match</span> moder.<span class="hljs-title function_ invoke__">get_mut</span>(&amp;value) {
			<span class="hljs-title function_ invoke__">Some</span>(keys) =&gt; {
				<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ks</span> = keys.<span class="hljs-title function_ invoke__">to_vec</span>();
				ks.<span class="hljs-title function_ invoke__">push</span>(**key);
				moder.<span class="hljs-title function_ invoke__">insert</span>(*value, ks);
			},
			<span class="hljs-literal">None</span> =&gt; {
				<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">keys</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
				keys.<span class="hljs-title function_ invoke__">push</span>(**key);
				moder.<span class="hljs-title function_ invoke__">insert</span>(*value, keys);
			}
		};
	}
	
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(keys) = moder.<span class="hljs-title function_ invoke__">get</span>(&amp;highest) {
		<span class="hljs-keyword">return</span> keys.<span class="hljs-title function_ invoke__">to_vec</span>()
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()
	};
}
</code></pre>
<p>When I asked ChatGPT how I can make the code more idiomatic. This was the response</p>
<blockquote>
<p>Here are some suggestions to make the Rust code more idiomatic:</p>
<ol>
<li>Use a <code>&amp;[u32]</code> slice instead of a <code>Vec&lt;u32&gt;</code> for the function parameters. This allows the function to accept both a <code>Vec&lt;u32&gt;</code> and a slice, which is more flexible.</li>
<li>Use <code>unwrap_or</code> instead of the <code>match</code> statement in the <code>mode</code> function to insert a value into the hash map with a default value of 1 if the key does not exist.</li>
<li>Use <code>entry</code> method to insert or update values in the hash map.</li>
<li>Use <code>iter()</code> method instead of a reference to iterate over the vector elements.</li>
<li>Use <code>collect</code> method to convert an iterator to a vector.</li>
<li>Use <code>copied</code> method to create an iterator over the copied elements.</li>
<li>Use <code>cloned</code> method to create an iterator over the cloned elements.</li>
</ol>
<p>Here&#x27;s the updated code:</p>
</blockquote>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::HashMap; 

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() { 
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nums</span> = <span class="hljs-built_in">vec!</span>[ <span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>, <span class="hljs-number">27</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">22</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-number">27</span>, <span class="hljs-number">29</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-number">4</span>, ]; 
    nums.<span class="hljs-title function_ invoke__">sort</span>(); 
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Median: {}&quot;</span>, <span class="hljs-title function_ invoke__">median</span>(&amp;nums));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Mode: {:?}&quot;</span>, <span class="hljs-title function_ invoke__">mode</span>(&amp;nums)); 
} 

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">median</span>(nums: &amp;[<span class="hljs-type">u32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> { 
    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = nums.<span class="hljs-title function_ invoke__">len</span>(); 
    <span class="hljs-keyword">match</span> length % <span class="hljs-number">2</span> { 
        <span class="hljs-number">0</span> =&gt; { 
            <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = nums[(length / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>]; 
            <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = nums[length / <span class="hljs-number">2</span>]; 
            (first asf32 + second <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>) / <span class="hljs-number">2</span>.
         },
         _ =&gt; nums[length / <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>, 
    } 
} 

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">mode</span>(nums: &amp;[<span class="hljs-type">u32</span>]) <span class="hljs-punctuation">-&gt;</span><span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt; { 
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>(); 
    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> nums.<span class="hljs-title function_ invoke__">iter</span>() { 
        *counter.<span class="hljs-title function_ invoke__">entry</span>(num).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>) += <span class="hljs-number">1</span>; 
    } 
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">moder</span>: HashMap&lt;<span class="hljs-type">u32</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>(); 
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">highest</span> = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;counter { 
        <span class="hljs-keyword">if</span> value &gt; &amp;highest { 
            highest = *value; 
        } 
        moder.<span class="hljs-title function_ invoke__">entry</span>(*value).<span class="hljs-title function_ invoke__">or_insert_with</span>(<span class="hljs-type">Vec</span>::new).<span class="hljs-title function_ invoke__">push</span>(*key); 
    } 
    moder.<span class="hljs-title function_ invoke__">get</span>(&amp;highest).<span class="hljs-title function_ invoke__">copied</span>().<span class="hljs-title function_ invoke__">unwrap_or_default</span>().<span class="hljs-title function_ invoke__">collect</span>() 
}
</code></pre>
<p>When running the program it produced the following errors</p>
<pre><code>error[E0308]: mismatched types
  --&gt; compiler.rs:41:59
   |
41 |         moder.entry(*value).or_insert_with(Vec::new).push(*key);
   |                                                      ---- ^^^^ expected `u32`, found `&amp;u32`
   |                                                      |
   |                                                      arguments to this function are incorrect
   |
note: associated function defined here
help: consider dereferencing the borrow
   |
41 |         moder.entry(*value).or_insert_with(Vec::new).push(**key);
   |                                                           +

error[E0277]: the trait bound `Vec&lt;u32&gt;: Copy` is not satisfied
  --&gt; compiler.rs:44:25
   |
44 |     moder.get(&amp;highest).copied().unwrap_or_default().collect()
   |                         ^^^^^^ the trait `Copy` is not implemented for `Vec&lt;u32&gt;`
   |
note: required by a bound in `Option::&lt;&amp;T&gt;::copied`

error[E0599]: `Vec&lt;u32&gt;` is not an iterator
  --&gt; compiler.rs:44:54
   |
44 |       moder.get(&amp;highest).copied().unwrap_or_default().collect()
   |                                                        ^^^^^^^ `Vec&lt;u32&gt;` is not an iterator; try calling `.into_iter()` or `.iter()`
   |
   = note: the following trait bounds were not satisfied:
           `Vec&lt;u32&gt;: Iterator`
           which is required by `&amp;mut Vec&lt;u32&gt;: Iterator`
           `[u32]: Iterator`
           which is required by `&amp;mut [u32]: Iterator`

error: aborting due to 3 previous errors

Some errors have detailed explanations: E0277, E0308, E0599.
For more information about an error, try `rustc --explain E0277`.
</code></pre>
<p>The first error complaining about using a <code>&amp;key</code> was easy to fix with another deference. The second error related to copying the <code>Vec&lt;u32&gt;</code> , a type on the heap, was fixed by cloning instead. <a href="https://stackoverflow.com/a/63127877/7838574">This stack overflow answer</a> helped figure that one out.</p>
<p>What did I learn from ChatGPTs revision?</p>
<ul>
<li>When borrowing a vector it it&#x27;s probably best to use a slice. <a href="https://stackoverflow.com/a/32573802/7838574">This stack overflow</a> elucidates it well.</li>
<li>Hashmap&#x27;s <code>Entry</code>&#x27;s are extremely helpful.</li>
</ul>
<blockquote>
<p>Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to the value in the entry. <a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">Rust docs</a></p>
</blockquote>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[Rust Book Examples]]></title>
            <link>https://daniel-butler.com/articles/rust-examples</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/rust-examples</guid>
            <pubDate>Sun, 05 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Rust Book example and solutions index. Refactored with ChatGPT 4s help.]]></description>
            <content:encoded><![CDATA[<h2>Introduction</h2>
<p>This is the collection of completed examples while working  though the excellently written <a href="https://doc.rust-lang.org/stable/book/">rust book</a> on a journey to learn Rust.</p>
<p>My experience with programming while going through this book is mostly python, a few years of JavaScript, a little less of typescript, and about a year and a half of Java. This is my second attempt to go through the book. At the time, types and differences in computers memory didn&#x27;t really click. This time around the decisions made with the language are making a lot more sense.</p>
<p>Since I don&#x27;t have any real world problems to solve with rust, I&#x27;m completing every example and will be posting it here. Also, to help give feedback and to test chat gpt I&#x27;m using it to review the code.</p>
<h2>Chapters</h2>
<h3>8</h3>
<ul>
<li>8.3 <a href="https://www.daniel-butler.com/articles/median-and-mode-rust">Median and Mode</a></li>
<li>8.3 <a href="https://www.daniel-butler.com/articles/ust-ray%E2%80%94y-bay%E2%80%94example-fay">Pig Latin</a></li>
<li>8.3 <a href="https://daniel-butler.com">Employee Directory</a></li>
</ul>
<h3>17</h3>
<ul>
<li>17.3 <a href="https://www.daniel-butler.com/articles/rust-dyn-traits-example">Dynamic Traits</a></li>
</ul>
<p>More to come!</p>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
        <item>
            <title><![CDATA[ust-ray y-bay example-fay]]></title>
            <link>https://daniel-butler.com/articles/ust-ray—y-bay—example-fay</link>
            <guid isPermaLink="false">https://daniel-butler.com/articles/ust-ray—y-bay—example-fay</guid>
            <pubDate>Fri, 03 Mar 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Python and Rust code helps translate English to Pig Latin! Learn how to speak like a pro with this code, and avoid the pitfalls of type mismatches in Rust.]]></description>
            <content:encoded><![CDATA[<p>This is a part of the series going through the <a href="https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#summary">rust book</a>. I&#x27;m most comfortable with python code, so I&#x27;ve sketched out the program to be written in rust with python first. It helps iron out misunderstandings.</p>
<h2>Requirements</h2>
<p>Convert strings to pig latin. The first consonant of each word is moved to the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words that start with a vowel have “hay” added to the end instead (“apple” becomes “apple-hay”). Keep in mind the details about UTF-8 encoding!</p>
<h2>Python Version</h2>
<pre><code class="hljs language-python">words = <span class="hljs-built_in">input</span>()

output_words = []
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words.split(<span class="hljs-string">&quot; &quot;</span>):
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) == <span class="hljs-number">0</span>:
		<span class="hljs-keyword">continue</span>
		
	start = <span class="hljs-string">&quot;&quot;</span>
	end = <span class="hljs-string">&quot;ay&quot;</span>
	new_word = <span class="hljs-string">&quot;&quot;</span>
	
	<span class="hljs-keyword">for</span> i, letter <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):
		<span class="hljs-keyword">if</span> letter.lower() <span class="hljs-keyword">in</span> [
			<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>,
		]:
			start = <span class="hljs-string">&quot;f&quot;</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> start
			new_word = <span class="hljs-string">f&quot;<span class="hljs-subst">{word[i:]}</span>-<span class="hljs-subst">{start}</span><span class="hljs-subst">{end}</span>&quot;</span>
			<span class="hljs-keyword">break</span>
		
		start += letter
		
	output_words.append(new_word)
	
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(output_words))
</code></pre>
<p>English Input
<code>This is a great example of what it means to speak a foreign language with class.</code></p>
<p>Translated
<code>is-Thay is-fay a-fay eat-gray example-fay of-fay at-whay it-fay eans-may o-tay eak-spay a-fay oreign-fay anguage-lay ith-way ass.-clay</code></p>
<h2>Rust version</h2>
<p>I did use this <a href="https://codereview.stackexchange.com/questions/278267/rust-pig-latin-exercise-solution">stack overflow</a> to unstick myself.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::io;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
	<span class="hljs-keyword">const</span> VOWELS: [<span class="hljs-type">char</span>; <span class="hljs-number">5</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>];

	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();
	io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> input).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;E most String&quot;</span>);
	<span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = input.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">to_string</span>();
	
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">translated_words</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
	<span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> input.<span class="hljs-title function_ invoke__">split_whitespace</span>() {
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">start</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">translated_word</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">complete</span> = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span> <span class="hljs-variable">letter</span> <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">chars</span>() {
			<span class="hljs-keyword">if</span> complete {
				translated_word.<span class="hljs-title function_ invoke__">push</span>(letter);
				<span class="hljs-keyword">continue</span>
			}
			
			<span class="hljs-keyword">if</span> VOWELS.<span class="hljs-title function_ invoke__">contains</span>(&amp;letter) {
				<span class="hljs-keyword">if</span> start.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">0</span> {
					start = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;f&quot;</span>);
				}
				translated_word.<span class="hljs-title function_ invoke__">push</span>(letter);
				complete = <span class="hljs-literal">true</span>;
				
			} <span class="hljs-keyword">else</span> {
				start.<span class="hljs-title function_ invoke__">push</span>(letter);
			}
		}
		
		translated_word = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{}-{}ay&quot;</span>, translated_word, start);
		
		translated_words.<span class="hljs-title function_ invoke__">push</span>(translated_word);
	}
	
	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, translated_words.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot; &quot;</span>))
}
</code></pre>
<p>English Input
<code>This is a great example of what it means to speak a foreign language with class.</code></p>
<p>Translated
<code>is-Thay is-fay a-fay eat-gray example-fay of-fay at-whay it-fay eans-may o-tay eak-spay a-fay oreign-fay anguage-lay ith-way ass.-clay</code></p>
<h2>Challenges</h2>
<p>Creating the <code>{}-{}ay</code> because of Type mismatch of <code>String</code> and <code>str</code>. The problem seemed to be because I was adding a vector of chars and a string together.</p>
<pre><code>error[E0308]: mismatched types
  --&gt; compiler.rs:31:22
   |
31 |         translated_word += format!(&quot;-{}ay&quot;, &amp;(*start.as_str()));
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&amp;str`, found struct `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
</code></pre>]]></content:encoded>
            <author>rss@daniel-butler.com (Daniel Butler)</author>
        </item>
    </channel>
</rss>